Django tutorial

created virtual environment called django_tutorial in ~/Documents/programming/webapps/django_lesson/

See gnote for command line details.  Search 'virtual environment'

Creation of a site:

# include the '.'
django-admin startproject mysite .


THE NAME OF MY VIRTUAL ENV IS : django_tutorial


django-admin.py is a script that will create the directories and files for you.
You should now have a directory structure which looks like this:

djangogirls
├───manage.py
└───mysite
        settings.py
        urls.py
        wsgi.py
        __init__.py


manage.py is a script that helps with management of the site. With it we will be able (amongst other things) to start a web server on our computer without installing anything else.

The settings.py file contains the configuration of your website.

Remember when we talked about a mail carrier checking where to deliver a letter? urls.py file contains a list of patterns used by urlresolver.

-------------

Modifying Settings.py

It would be nice to have the correct time on our website. Go to Wikipedia's list of time zones and copy your relevant time zone (TZ) (e.g. Europe/Berlin).
America/Chicago

We'll also need to add a path for static files. (We'll find out all about static files and CSS later in the tutorial.) Go down to the end of the file, and just underneath the STATIC_URL entry, add a new one called STATIC_ROOT:

mysite/settings.py

STATIC_URL = '/static/'
STATIC_ROOT = os.path.join(BASE_DIR, 'static')

When DEBUG is True and ALLOWED_HOSTS is empty, the host is validated against ['localhost', '127.0.0.1', '[::1]']. This won't match our hostname on PythonAnywhere once we deploy our application so we will change the following setting:

mysite/settings.py

ALLOWED_HOSTS = ['127.0.0.1', '.pythonanywhere.com']

--

Set up a database

There's a lot of different database software that can store data for your site. We'll use the default one, sqlite3.

This is already set up in this part of your mysite/settings.py file:

mysite/settings.py

DATABASES = {
    'default': {
        'ENGINE': 'django.db.backends.sqlite3',
        'NAME': os.path.join(BASE_DIR, 'db.sqlite3'),
    }
}

To create a database for our blog, let's run the following in the console: __python manage.py migrate__ (we need to be in the djangogirls directory that contains the manage.py file). 

# This creates a pre-canned sqlite db file that includes a bunch of tables that are relevant to managing a website.  Pretty neat.

---------------

##Starting the web server

You need to be in the directory that contains the manage.py file (the djangogirls directory). In the console, we can start the web server by running __python manage.py runserver__:

http://127.0.0.1:8000/

-------------------------


#Django models

Django uses object oriented programming schemas.

A model in Django is a special kind of object – it is saved in the database. A database is a collection of data. This is a place in which you will store information about users, your blog posts, etc. We will be using a SQLite database to store our data. This is the default Django database adapter – it'll be enough for us right now.

---------------------------

# Creating an application

To keep everything tidy, we will create a separate application inside our project. It is very nice to have everything organized from the very beginning. To create an application we need to run the following command in the console (from djangogirls directory where manage.py file is):

(myvenv) ~/djangogirls$ python manage.py startapp blog$

(apparently there are template webapp forms)

You will notice that a new blog directory is created and it contains a number of files now. The directories and files in our project should look like this:

djangogirls
├── blog
│   ├── __init__.py
│   ├── admin.py
│   ├── apps.py
│   ├── migrations
│   │   └── __init__.py
│   ├── models.py
│   ├── tests.py
│   └── views.py
├── db.sqlite3
├── manage.py
└── mysite
    ├── __init__.py
    ├── settings.py
    ├── urls.py
    └── wsgi.py


After creating an application, we also need to tell Django that it should use it. We do that in the file mysite/settings.py. We need to find INSTALLED_APPS and add a line containing 'blog', just above ]. So the final product should look like this:

mysite/settings.py

INSTALLED_APPS = [
    'django.contrib.admin',
    'django.contrib.auth',
    'django.contrib.contenttypes',
    'django.contrib.sessions',
    'django.contrib.messages',
    'django.contrib.staticfiles',
    'blog',
]

# Creating a blog post model

In the blog/models.py file we define all objects called Models – this is a place in which we will define our blog post.

Let's open blog/models.py, remove everything from it, and write code like this:

blog/models.py


```python

from django.db import models
from django.utils import timezone

class Post(models.Model):
    author = models.ForeignKey('auth.User')
    title = models.CharField(max_length=200)
    text = models.TextField()
    created_date = models.DateTimeField(
            default=timezone.now)
    published_date = models.DateTimeField(
            blank=True, null=True)

    def publish(self):
        self.published_date = timezone.now()
        self.save()

    def __str__(self):
        return self.title
```

models.Model means that the Post is a Django Model, so Django knows that it should be saved in the database.


------------

# Updating Changes

The last step here is to add our new model to our database. First we have to make Django know that we have some changes in our model. (We have just created it!) Go to your console window and type python manage.py makemigrations blog. It will look like this:

command-line

(myvenv) ~/djangogirls$ python manage.py makemigrations blog $
Migrations for 'blog':
  blog/migrations/0001_initial.py:
  - Create model Post

Django prepared a migration file for us that we now have to apply to our database. Type python manage.py migrate blog and the output should be as follows:

command-line

(myvenv) ~/djangogirls$ python manage.py migrate blog $
Operations to perform:
  Apply all migrations: blog
Running migrations:
  Rendering model states... DONE
  Applying blog.0001_initial... OK


--------------------

#Django admin

To add, edit and delete the posts we've just modeled, we will use Django admin.

Let's open the blog/admin.py file and replace its contents with this:

blog/admin.py

```python
from django.contrib import admin
from .models import Post

admin.site.register(Post)
```
As you can see, we import (include) the Post model defined in the previous chapter. To make our model visible on the admin page, we need to register the model with admin.site.register(Post).

OK, time to look at our Post model. Remember to run $ python manage.py runserver $ in the console to run the web server. Go to your browser and type the address http://127.0.0.1:8000/admin/. 

To log in, you need to create a superuser - a user account that has control over everything on the site. Go back to the command line, type $ python manage.py createsuperuser $, and press enter.

__
Superuser: t42
pass: template
__


# Deploying your website:

These three places will be important to you. Your local computer will be the place where you do development and testing. When you're happy with the changes, you will place a copy of your program on GitHub. Your website will be on PythonAnywhere and you will update it by getting a new copy of your code from GitHub.

Steps:
$ 
git init
$

Git will track changes to all the files and folders in this directory, but there are some files we want it to ignore. We do this by creating a file called .gitignore in the base directory. Open up your editor and create a new file with the following contents:

.gitignore

*.pyc
*~
__pycache__
myvenv
db.sqlite3
/static
.DS_Store

Note One of the files you specified in your .gitignore file is db.sqlite3. That file is your local database, where all of your posts are stored. We don't want to add this to your repository because your website on PythonAnywhere is going to be using a different database. That database could be SQLite, like your development machine, but usually you will use one called MySQL which can deal with a lot more site visitors than SQLite. Either way, by ignoring your SQLite database for the GitHub copy, it means that all of the posts you created so far are going to stay and only be available locally, but you're going to have to add them again on production. You should think of your local database as a good playground where you can test different things and not be afraid that you're going to delete your real posts from your blog.

It's a good idea to use a $
git status
$ command before git add or whenever you find yourself unsure of what has changed. This will help prevent any surprises from happening, such as wrong files being added or committed. The git status command returns information about any untracked/modified/staged files, the branch status, and much more. 
